<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /*nicotext*/
        .nicotext{
            position: fixed;
            top: 0;
            right: 0;
            background-color: #f0f8ff80;
            color: #000000;
            font-size: 20px;
            transition: right 2.0s linear;
            white-space: nowrap;
            pointer-events: none;
        }
        /*logとtext*/
        #log{
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            width: 320px;
            height: 200px;
            border: 1px solid #ffffff;
            background-color: rgba(0,0,0,0);
            position: fixed;
            bottom: 150px;
            right: -300px;
            color: #fefefe;
            overflow-y: hidden;
            transition: right 0.3s;
            z-index: 254;
        }
        #log .opener{
            width: 20px;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            color: #fefefe;
            text-align: center;
            cursor: pointer;
            z-index: 254;
        }
        #log .log{
            width: 300px;
            height: 100%;
            max-height: 200px;
            overflow-x: hidden;
            overflow-y: scroll;
            background-color: rgba(0,0,0,0.8);
            color: #fefefe;
            text-align: left;
            font-size: 14px;
            transition: right 0.3s;
            z-index: 253;
        }
        #text{
            display: none;
            background: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 1.2em;
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;

            white-space: nowrap;
            overflow: hidden;
            width: fit-content; /* 文字の長さに応じた幅 */
            animation: fadeIn 0.5s ease forwards;
        }
        @keyframes fadeIn {
            0%{
                opacity: 0;
            }
            100%{
                opacity: 1;
            }
        }
        .color-red{
            color: #ff1919;
        }
        .color-pink{
            color: #ff56e9;
        }
        .color-blue{
            color: #1919ff;
        }

        /* description */
        #movableDescription{
            display: none;
            position: fixed;
            pointer-events: none;
            background-color: #363636e2;
            color: #f0f8ff;
            text-align: left;
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 256;
        }
    </style>
</head>
<body>
    <div id="text"></div>
    <div id="log" style="right: -300px;">
        <div class="opener">‹</div>
        <div class="log"></div>
    </div>
    <div id="movableDescription"></div>

    <script>
        //#region komagome
        function delay(ms){
            return new Promise(resolve=>setTimeout(resolve,ms));
        };
        async function nicoText(mes){
            const newDiv = document.createElement('div');
            newDiv.textContent = mes;
            newDiv.className = 'nicotext';
            newDiv.style.top = `calc(${random(0, 100)}vh - 20px)`;
            newDiv.style.right = '0px';
            document.querySelector('body').appendChild(newDiv);

            requestAnimationFrame(() => {
                newDiv.style.right = `${window.innerWidth + newDiv.offsetWidth}px`; //なんか電車の問題解いてるみたいだね
            });
            
            await delay(2000); 
            newDiv.remove();
        };
        function kaijou(num){
            if(num == 0) return 0;
            if(num == 1) return 1;
            return num * kaijou(num - 1);
        }
        function arraySelect(array){
            let select = Math.floor(Math.random()*array.length);
            return array[select];
        };
        function arrayShuffle(array) {
            for(let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };
        function arraySize(array){
            let res = new Set(array).size;
            return res;
        };
        function arrayCount(array){
            const counts = {};
            for (let value of array) {
                counts[value] = (counts[value] || 0) + 1;
            }
            return counts;
        }
        function arrayMult(array){
            return array.reduce((a, v) => a * v, 1);
        }
        function arrayGacha(array,probability){
            if(array.length !== probability.length){throw new Error("長さがあってないっす！先輩、ちゃんとチェックした方がいいっすよ〜？");}
            const total = probability.reduce((sum, p) => sum + p, 0);
            let random = Math.random() * total;
            for (let i = 0; i < array.length; i++) {
                if(random < probability[i]){
                return array[i];
                }
                random -= probability[i];
            }
        };
        function copy(obj){
            if (obj === null || typeof obj !== 'object') {
                return obj; // 基本型はそのまま返す
            }
            if (Array.isArray(obj)) {
                return obj.map(copy); // 配列の各要素を再帰コピー
            }
            const result = {};
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    result[key] = copy(obj[key]); // オブジェクトのプロパティを再帰コピー
                }
            }
            return result;
        };
        function probability(num){
            return Math.random()*100 <= num;
            //例:num == 20 → randomが20以内ならtrue,elseならfalseを返す
        };
        function random(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        };

        function anagramSaySay(text, loop = 10, bet = '<br>'){
            let menjo = 0;
            let len = text.length;
            if(len < 4) menjo = 1, console.log('長さが3以下なんで最大6っす');
            
            let optout = text.split('');
            let optcou = arrayCount(optout);
            let optvals = [];
            for(a of Object.keys(optcou)){
                let b = optcou[a];
                b = kaijou(b);
                optvals.push(b);
            }
            let optmat = arrayMult(optvals);
            let cal = (kaijou(len) / optmat) - 1;

            let loopen = loop;
            console.log(`総数:${cal} 回数:${loopen}`);
            if(cal < loopen) menjo = 1;
            
            let reses = [];
            while(loopen > 0){
                loopen -= 1;
                let res = arrayShuffle(optout).join(''); 
                if(reses.includes(res)){loopen += 1; continue}
                
                if(res == text && !menjo){loopen += 1; continue;}

                if(res == text && menjo && reses.length < cal){loopen += 1; continue}
                else if(res == text && menjo) res = '[重複エラー]';

                reses.push(res);
            }
            
            return reses.join(bet);
        }
        function setLocalStorage(name, value) {
            localStorage.setItem(name, value || "");
        }
        function getLocalStorage(name) {
            return localStorage.getItem(name);
        }
        async function error(){
            addtext('errrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr')
            await delay(2000);
            window.open('about:blank', '_self').close();
        }
        //#endregion
        //#region log&text
        let textDiv = document.querySelector('#text');
        let autoDelay = 1;
        let skipText = false; // スキップフラグ
        let clearText = false; // テキスト消去フラグ
        let textShowing = 0;

        function colorcheck(rawtext) {
            const text = [];
            let isRed = false; // ** で囲まれた部分かどうか
            let isPink = false; // && で囲まれた部分かどうか
            let isBlue = false; // ^^ で囲まれた部分かどうか

            for(let i = 0; i < rawtext.length; i++){
                if(rawtext[i] === "*" && rawtext[i + 1] === "*"){
                    isRed = !isRed; // 状態を切り替える
                    i++; // 次の * をスキップ
                }else if(rawtext[i] === "&" && rawtext[i + 1] === "&"){
                    isPink = !isPink;
                    i++; // 次の & をスキップ
                }else if(rawtext[i] === "^" && rawtext[i + 1] === "^"){
                    isBlue = !isBlue;
                    i++;
                }else{
                    text.push({ char: rawtext[i], color: isRed ? "red" : isPink ? "pink" : isBlue ? "blue" : null });
                }
            }
            return text;
        }

        async function addtext(text){
            textShowing = 1;
            text = colorcheck(text);
            textDiv.innerHTML = ""; // 中身をリセット
            textDiv.style.display = "block"; // 表示
            let index = 0;
            clearText = false; // 消去フラグをリセット

            return new Promise((resolve) => {
                async function type() {
                        if (index < text.length) {
                        if (skipText) {
                            // スキップ処理
                            while (index < text.length) {
                                    const span = document.createElement("span");
                                    span.textContent = text[index].char;
                                    if (text[index].color) {
                                    span.classList.add(`color-${text[index].color}`);
                                    }
                                    textDiv.appendChild(span);
                                    index++;
                            }
                            index = text.length; // 全ての文字を表示済みにする
                            skipText = false;
                            setTimeout(type, 10);
                        } else {
                            // 通常の文字表示
                            const span = document.createElement("span");
                            span.textContent = text[index].char;
                            if (text[index].color) {
                                    span.classList.add(`color-${text[index].color}`);
                            }
                            textDiv.appendChild(span);

                            index++;
                            setTimeout(type, 80); // 次の文字を表示する間隔
                        }
                        } else {
                        addlog(textDiv.innerHTML);
                        const waitTime = autoDelay * 1000;
                        const timeout = new Promise(resolve => setTimeout(resolve, waitTime));
                        const userAction = new Promise(resolve => {
                            function waitToClear(event) {
                                    if (event.type === 'click' || event.key === 'z' || event.key === 'Enter') {
                                    document.removeEventListener('click', waitToClear);
                                    document.removeEventListener('keydown', waitToClear);
                                    resolve();
                                    }
                            }
                            document.addEventListener('click', waitToClear);
                            document.addEventListener('keydown', waitToClear);
                        });

                        Promise.race([timeout, userAction]).then(() => {
                            textDiv.textContent = "";
                            textDiv.style.display = "none";
                            clearText = true;
                            skipText = false
                            textShowing = 0;
                            resolve('end'); // Promiseを解決
                        });
                        }
                }
                type();
            });
        }
        document.addEventListener('keydown', (event) => {
            if(event.key === 'z' || event.key === 'Enter'){
                skipText = true;
            }
        });

        document.addEventListener('keyup', (event) => {
            if(event.key === 'z' || event.key === 'Enter'){
                skipText = false;
            }
        });

        document.addEventListener('click', () => {
            skipText = true;
            setTimeout(() => skipText = false, 50); // 一時的にスキップを有効化
        });

        let logOOmoto = document.querySelector('#log');
        let log = document.querySelector('#log .log');
        let logOpener = document.querySelector('#log .opener');
        logOpener.addEventListener('click', function(){
            if(logOOmoto.style.right == '-300px'){
                logOOmoto.style.right = '0px';
                logOpener.textContent = '>';
            }else{
                logOOmoto.style.right = '-300px';
                logOpener.textContent = '<';
            }
        });
        function addlog(text){
            log.innerHTML += text + '<br>';
            log.scrollTop = log.scrollHeight;
        }
        //#endregion
        //#region description
        let movableDescription = document.getElementById('movableDescription');
        document.addEventListener('mousemove', (e) => {
            movableDescription.style.left = `${e.clientX + 10}px`;
            movableDescription.style.top = `${e.clientY + 10}px`;
        });
        document.addEventListener('mouseover', (e) => {
            const descTarget = e.target.closest('[data-description]');
            if (descTarget) {
                const desc = descTarget.dataset.description;
                movableDescription.innerHTML = desc;
                movableDescription.style.display = 'block';
            }
        });
        document.addEventListener('mouseout', (e) => {
            const descTarget = e.target.closest('[data-description]');
            if (descTarget) {
                movableDescription.innerHTML = '';
                movableDescription.style.display = 'none';
            }
        });
        //#endregion
        //#region drag
        document.addEventListener('mousedown', e => {
            // const descTarget = e.target.closest('[data-description]');
            let div = e.target;
            if(!div.classList.contains('draggable')) return;
            offsetX = e.clientX - div.getBoundingClientRect().left;
            offsetY = e.clientY - div.getBoundingClientRect().top;
            
            function onMouseMove(e) {
                div.style.left = `${e.clientX - offsetX}px`;
                div.style.top = `${e.clientY - offsetY}px`;
            }

            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
        //#endregion
    </script>
</body>
</html>